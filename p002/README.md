## Problem 2 - Even Fibonacci numbers
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

## Non-optimized Solution (Version 1)
The fibonacci sequence is defined as
```
f(n+1) = f(n) + f(n-1), f(0) = 1, f(1) = 1.
```
We can just iterate and stop after the last value is added.
Here is a go-code:
```go
func SumEvenFibonacciV1(n int) int {
	acc := 0
	for old, new := 1, 1; new <= n; old, new = new, old+new {
		if new%2 == 0 {
			acc += new
		}
	}
	return acc
}
```
A drawback with this algorithm is that we have to check if the ```new``` variable is even, which is relatively costly, even though the algorithm is extremely fast.

## Optimized Solution (Version 2)
A slight optimization is to realize that every third number in the sequence is even, and only update the odd ones. Some trivial algebra gives the following go-code:
```go
func SumEvenFibonacciV2(n int) int {
	acc := 0
	for odd1, odd2 := 1, 1; odd1+odd2 <= n; odd1, odd2 = odd1+2*odd2, 2*odd1+3*odd2 {
		acc += odd1 + odd2
	}
	return acc
}
```

## Test and Benchmarks of algorithms
We have the code-snippet:
```go
func TestSumEvenFibonacciV1(t *testing.T) {
	assert.Equal(t, 4613732, p002.SumEvenFibonacciV1(4000000))
}

func TestSumEvenFibonacciV2(t *testing.T) {
	assert.Equal(t, 4613732, p002.SumEvenFibonacciV2(4000000))
}

func BenchmarkSumEvenFibonacciV1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		p002.SumEvenFibonacciV1(4000000)
	}
}

func BenchmarkSumEvenFibonacciV2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		p002.SumEvenFibonacciV2(4000000)
	}
}
```

We run the test with the command:
```
go test -bench=.
```
with the output
```
goos: darwin
goarch: amd64
pkg: github.com/andreasatle/ProjectEuler100/p002
BenchmarkSumEvenFibonacciV1-12    	63014185	        17.1 ns/op
BenchmarkSumEvenFibonacciV2-12    	175075660	         6.92 ns/op
PASS
ok  	github.com/andreasatle/ProjectEuler100/p002	3.019s
```

The optimized version is about 2.5 times faster than the non-optimized.
The recursion is inherently sequential, and I will not even attemp to use concurrency for this problem. It is just not enough terms in the sum for the overhead of the concurrency to be worth it.