## Problem 12 - Highly divisible Triangle number

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

```
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
```

Let us list the factors of the first seven triangle numbers:

```
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
```
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

## Brute force solution
```go
func numberOfDivisors(n int) int {

	div := 1
	for _, p := range primes {
		if p > n {
			break
		}
		nPow := 0
		for n%p == 0 {
			n /= p
			nPow++
		}
		div *= nPow + 1
	}

	return div
}

func FindTrianguleNumberWithNDivisorsV1(nDivisors int) int {

	for n := 1; ; n++ {
		tri := (n * (n + 1)) / 2
		div := numberOfDivisors(tri)
		if div >= nDivisors {
			return tri
		}
	}
}
```

We can optimize this a bit, by computing even and odd in the same loop. We can deduce that
```
numberOfDivisors((2*n-1)*n) = numberOfDivisors(2*n-1)*numberOfDivisors(n),
numberOfDivisors((2*n+1)*n) = numberOfDivisors(2*n+1)*numberOfDivisors(n).
```

An optimized code:
```go
func FindTrianguleNumberWithNDivisorsV2(nDivisors int) int {

	divOdd := numberOfDivisors(1)
	for n := 1; ; n++ {
		// odd == 2*n-1, even == 2*n
		divN := numberOfDivisors(n)
		if divN*divOdd >= nDivisors {
			return n * (2*n - 1)
		}

		// odd == 2*n+1, even == 2*n
		divOdd = numberOfDivisors(2*n + 1)
		if divN*divOdd >= nDivisors {
			return n * (2*n + 1)
		}
	}
}
```

## Benchmark and tests
Code:
```go
func TestFindTrianguleNumberWithNDivisorsV1N5(t *testing.T) {
	assert.Equal(t, 28, p012.FindTrianguleNumberWithNDivisorsV1(5))
}

func TestFindTrianguleNumberWithNDivisorsV1N500(t *testing.T) {
	assert.Equal(t, 76576500, p012.FindTrianguleNumberWithNDivisorsV1(500))
}

func BenchmarkFindTrianguleNumberWithNDivisorsV1N500(b *testing.B) {
	for i := 0; i < b.N; i++ {
		p012.FindTrianguleNumberWithNDivisorsV1(500)
	}
}

func TestFindTrianguleNumberWithNDivisorsV2N5(t *testing.T) {
	assert.Equal(t, 28, p012.FindTrianguleNumberWithNDivisorsV2(5))
}

func TestFindTrianguleNumberWithNDivisorsV2N500(t *testing.T) {
	assert.Equal(t, 76576500, p012.FindTrianguleNumberWithNDivisorsV2(500))
}

func BenchmarkFindTrianguleNumberWithNDivisorsV2N500(b *testing.B) {
	for i := 0; i < b.N; i++ {
		p012.FindTrianguleNumberWithNDivisorsV2(500)
	}
}
```
with output:
```
âœ— go test -bench=. -v
=== RUN   TestFindTrianguleNumberWithNDivisorsV1N5
--- PASS: TestFindTrianguleNumberWithNDivisorsV1N5 (0.00s)
=== RUN   TestFindTrianguleNumberWithNDivisorsV1N500
--- PASS: TestFindTrianguleNumberWithNDivisorsV1N500 (0.04s)
=== RUN   TestFindTrianguleNumberWithNDivisorsV2N5
--- PASS: TestFindTrianguleNumberWithNDivisorsV2N5 (0.00s)
=== RUN   TestFindTrianguleNumberWithNDivisorsV2N500
--- PASS: TestFindTrianguleNumberWithNDivisorsV2N500 (0.02s)
goos: darwin
goarch: amd64
pkg: github.com/andreasatle/ProjectEuler100/p012
BenchmarkFindTrianguleNumberWithNDivisorsV1N500
BenchmarkFindTrianguleNumberWithNDivisorsV1N500-12    	      37	  31295372 ns/op
BenchmarkFindTrianguleNumberWithNDivisorsV2N500
BenchmarkFindTrianguleNumberWithNDivisorsV2N500-12    	      67	  18014173 ns/op
PASS
ok  	github.com/andreasatle/ProjectEuler100/p012	2.486s
```
We can see that the optimized version where we split the divisor call into two smaller calls is 70% faster.